// This file was generated by nomdl/codegen.

package decode

import (
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

var __decodePackageInFile_types_CachedRef = __decodePackageInFile_types_Ref()

// This function builds up a Noms value that describes the type
// package implemented by this file and registers it with the global
// type package definition cache.
func __decodePackageInFile_types_Ref() types.Ref {
	p := types.PackageDef{
		Types: types.MapOfStringToTypeRefDef{

			"A1": __typeRefOfA1(),
			"A2": __typeRefOfA2(),
			"A3": __typeRefOfA3(),
		},
	}.New()
	return types.Ref{R: types.RegisterPackage(&p)}
}

// A1

type A1 struct {
	m types.Map
}

func NewA1() A1 {
	return A1{types.NewMap(
		types.NewString("$name"), types.NewString("A1"),
		types.NewString("$type"), types.MakeTypeRef("A1", __decodePackageInFile_types_CachedRef),
		types.NewString("x"), types.Int16(0),
		types.NewString("s"), types.NewString(""),
		types.NewString("b"), types.Bool(false),
	)}
}

type A1Def struct {
	X int16
	S string
	B bool
}

func (def A1Def) New() A1 {
	return A1{
		types.NewMap(
			types.NewString("$name"), types.NewString("A1"),
			types.NewString("$type"), types.MakeTypeRef("A1", __decodePackageInFile_types_CachedRef),
			types.NewString("x"), types.Int16(def.X),
			types.NewString("s"), types.NewString(def.S),
			types.NewString("b"), types.Bool(def.B),
		)}
}

func (s A1) Def() (d A1Def) {
	d.X = int16(s.m.Get(types.NewString("x")).(types.Int16))
	d.S = s.m.Get(types.NewString("s")).(types.String).String()
	d.B = bool(s.m.Get(types.NewString("b")).(types.Bool))
	return
}

// Creates and returns a Noms Value that describes A1.
func __typeRefOfA1() types.TypeRef {
	return types.MakeStructTypeRef("A1",
		[]types.Field{
			types.Field{"x", types.MakePrimitiveTypeRef(types.Int16Kind), false},
			types.Field{"s", types.MakePrimitiveTypeRef(types.StringKind), false},
			types.Field{"b", types.MakePrimitiveTypeRef(types.BoolKind), false},
		},
		types.Choices{},
	)
}

func A1FromVal(val types.Value) A1 {
	// TODO: Validate here
	return A1{val.(types.Map)}
}

func (s A1) NomsValue() types.Value {
	return s.m
}

func (s A1) Equals(other A1) bool {
	return s.m.Equals(other.m)
}

func (s A1) Ref() ref.Ref {
	return s.m.Ref()
}

func (s A1) Type() types.TypeRef {
	return s.m.Get(types.NewString("$type")).(types.TypeRef)
}

func (s A1) X() int16 {
	return int16(s.m.Get(types.NewString("x")).(types.Int16))
}

func (s A1) SetX(val int16) A1 {
	return A1{s.m.Set(types.NewString("x"), types.Int16(val))}
}

func (s A1) S() string {
	return s.m.Get(types.NewString("s")).(types.String).String()
}

func (s A1) SetS(val string) A1 {
	return A1{s.m.Set(types.NewString("s"), types.NewString(val))}
}

func (s A1) B() bool {
	return bool(s.m.Get(types.NewString("b")).(types.Bool))
}

func (s A1) SetB(val bool) A1 {
	return A1{s.m.Set(types.NewString("b"), types.Bool(val))}
}

// A2

type A2 struct {
	m types.Map
}

func NewA2() A2 {
	return A2{types.NewMap(
		types.NewString("$name"), types.NewString("A2"),
		types.NewString("$type"), types.MakeTypeRef("A2", __decodePackageInFile_types_CachedRef),
		types.NewString("x"), types.Float32(0),
		types.NewString("$unionIndex"), types.UInt32(0),
		types.NewString("$unionValue"), types.Bool(false),
	)}
}

type A2Def struct {
	X            float32
	__unionIndex uint32
	__unionValue interface{}
}

func (def A2Def) New() A2 {
	return A2{
		types.NewMap(
			types.NewString("$name"), types.NewString("A2"),
			types.NewString("$type"), types.MakeTypeRef("A2", __decodePackageInFile_types_CachedRef),
			types.NewString("x"), types.Float32(def.X),
			types.NewString("$unionIndex"), types.UInt32(def.__unionIndex),
			types.NewString("$unionValue"), def.__unionDefToValue(),
		)}
}

func (s A2) Def() (d A2Def) {
	d.X = float32(s.m.Get(types.NewString("x")).(types.Float32))
	d.__unionIndex = uint32(s.m.Get(types.NewString("$unionIndex")).(types.UInt32))
	d.__unionValue = s.__unionValueToDef()
	return
}

func (def A2Def) __unionDefToValue() types.Value {
	switch def.__unionIndex {
	case 0:
		return types.Bool(def.__unionValue.(bool))
	case 1:
		return types.NewString(def.__unionValue.(string))
	}
	panic("unreachable")
}

func (s A2) __unionValueToDef() interface{} {
	switch uint32(s.m.Get(types.NewString("$unionIndex")).(types.UInt32)) {
	case 0:
		return bool(s.m.Get(types.NewString("$unionValue")).(types.Bool))
	case 1:
		return s.m.Get(types.NewString("$unionValue")).(types.String).String()
	}
	panic("unreachable")
}

// Creates and returns a Noms Value that describes A2.
func __typeRefOfA2() types.TypeRef {
	return types.MakeStructTypeRef("A2",
		[]types.Field{
			types.Field{"x", types.MakePrimitiveTypeRef(types.Float32Kind), false},
		},
		types.Choices{
			types.Field{"b", types.MakePrimitiveTypeRef(types.BoolKind), false},
			types.Field{"s", types.MakePrimitiveTypeRef(types.StringKind), false},
		},
	)
}

func A2FromVal(val types.Value) A2 {
	// TODO: Validate here
	return A2{val.(types.Map)}
}

func (s A2) NomsValue() types.Value {
	return s.m
}

func (s A2) Equals(other A2) bool {
	return s.m.Equals(other.m)
}

func (s A2) Ref() ref.Ref {
	return s.m.Ref()
}

func (s A2) Type() types.TypeRef {
	return s.m.Get(types.NewString("$type")).(types.TypeRef)
}

func (s A2) X() float32 {
	return float32(s.m.Get(types.NewString("x")).(types.Float32))
}

func (s A2) SetX(val float32) A2 {
	return A2{s.m.Set(types.NewString("x"), types.Float32(val))}
}

func (s A2) B() (val bool, ok bool) {
	if s.m.Get(types.NewString("$unionIndex")).(types.UInt32) != 0 {
		return
	}
	return bool(s.m.Get(types.NewString("$unionValue")).(types.Bool)), true
}

func (s A2) SetB(val bool) A2 {
	return A2{s.m.Set(types.NewString("$unionIndex"), types.UInt32(0)).Set(types.NewString("$unionValue"), types.Bool(val))}
}

func (def A2Def) B() (val bool, ok bool) {
	if def.__unionIndex != 0 {
		return
	}
	return def.__unionValue.(bool), true
}

func (def A2Def) SetB(val bool) A2Def {
	def.__unionIndex = 0
	def.__unionValue = val
	return def
}

func (s A2) S() (val string, ok bool) {
	if s.m.Get(types.NewString("$unionIndex")).(types.UInt32) != 1 {
		return
	}
	return s.m.Get(types.NewString("$unionValue")).(types.String).String(), true
}

func (s A2) SetS(val string) A2 {
	return A2{s.m.Set(types.NewString("$unionIndex"), types.UInt32(1)).Set(types.NewString("$unionValue"), types.NewString(val))}
}

func (def A2Def) S() (val string, ok bool) {
	if def.__unionIndex != 1 {
		return
	}
	return def.__unionValue.(string), true
}

func (def A2Def) SetS(val string) A2Def {
	def.__unionIndex = 1
	def.__unionValue = val
	return def
}

// A3

type A3 struct {
	m types.Map
}

func NewA3() A3 {
	return A3{types.NewMap(
		types.NewString("$name"), types.NewString("A3"),
		types.NewString("$type"), types.MakeTypeRef("A3", __decodePackageInFile_types_CachedRef),
		types.NewString("x"), types.Float32(0),
	)}
}

type A3Def struct {
	X float32
	S string
	B bool
}

func (def A3Def) New() A3 {
	return A3{
		types.NewMap(
			types.NewString("$name"), types.NewString("A3"),
			types.NewString("$type"), types.MakeTypeRef("A3", __decodePackageInFile_types_CachedRef),
			types.NewString("x"), types.Float32(def.X),
			types.NewString("s"), types.NewString(def.S),
			types.NewString("b"), types.Bool(def.B),
		)}
}

func (s A3) Def() (d A3Def) {
	d.X = float32(s.m.Get(types.NewString("x")).(types.Float32))
	if v, ok := s.m.MaybeGet(types.NewString("s")); ok {
		d.S = v.(types.String).String()
	}
	if v, ok := s.m.MaybeGet(types.NewString("b")); ok {
		d.B = bool(v.(types.Bool))
	}
	return
}

// Creates and returns a Noms Value that describes A3.
func __typeRefOfA3() types.TypeRef {
	return types.MakeStructTypeRef("A3",
		[]types.Field{
			types.Field{"x", types.MakePrimitiveTypeRef(types.Float32Kind), false},
			types.Field{"s", types.MakePrimitiveTypeRef(types.StringKind), true},
			types.Field{"b", types.MakePrimitiveTypeRef(types.BoolKind), true},
		},
		types.Choices{},
	)
}

func A3FromVal(val types.Value) A3 {
	// TODO: Validate here
	return A3{val.(types.Map)}
}

func (s A3) NomsValue() types.Value {
	return s.m
}

func (s A3) Equals(other A3) bool {
	return s.m.Equals(other.m)
}

func (s A3) Ref() ref.Ref {
	return s.m.Ref()
}

func (s A3) Type() types.TypeRef {
	return s.m.Get(types.NewString("$type")).(types.TypeRef)
}

func (s A3) X() float32 {
	return float32(s.m.Get(types.NewString("x")).(types.Float32))
}

func (s A3) SetX(val float32) A3 {
	return A3{s.m.Set(types.NewString("x"), types.Float32(val))}
}

func (s A3) S() (v string, ok bool) {
	var vv types.Value
	if vv, ok = s.m.MaybeGet(types.NewString("s")); ok {
		v = vv.(types.String).String()
	}
	return
}

func (s A3) SetS(val string) A3 {
	return A3{s.m.Set(types.NewString("s"), types.NewString(val))}
}

func (s A3) B() (v bool, ok bool) {
	var vv types.Value
	if vv, ok = s.m.MaybeGet(types.NewString("b")); ok {
		v = bool(vv.(types.Bool))
	}
	return
}

func (s A3) SetB(val bool) A3 {
	return A3{s.m.Set(types.NewString("b"), types.Bool(val))}
}
